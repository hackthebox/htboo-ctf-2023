![](https://github.com/hackthebox/writeup-templates/raw/master/challenge/assets/images/banner.png)

<img src="https://github.com/hackthebox/writeup-templates/raw/master/challenge/assets/images/htb.png" style="margin-left: 20px; zoom: 80%;" align=left/><font size="6">Initialization</font>

​	17<sup>th</sup> July 2023 / Document No. D22.102.16

​	Prepared By: `aris`

​	Challenge Author(s): `aris`

​	Difficulty: <font color=green>Very Easy</font>

​	Classification: Official

# Synopsis

- This challenges showcases a bug in the key generation algorithm. Due to the way the nested list is initialised, all the encryption keys are the same as well as the counters too. Therefore there is a keystream reuse vulnerability and the AES CTR encryption can be broken with a few XOR operations.

## Description

- During the pranking labs, the ghosts create a spooky encryption algorithm, and at midnight, they go outside to scare people by encrypting every device they own. To assess the situation at the end of the night, the professors have developed a spooky meter to measure how much people were spooked by the ransomware. The goal is to create irreversible ransomware that inflicts maximum damage. However, having interacted with humans over the past months, you've grown fond of them and don't want to harm them. You even managed to befriend a human who fell victim to such an attack. Can you help your friend unlock his files?

## Skills Required

- Good source code analysis.
- Knowledge how python initialises nested lists.
- Know how AES-CTR works.
- Basic researching skills.

## Skills Learned

- Exploit AES CTR when key and nonce are reused.
- Grow the habit of running the provided script locally and test with known values.
- Understand how the Counter module is initialized.
- Learn how to properly initialise nested lists in Python.

# Enumeration

## Analyzing the challenge

For this challenge, we are provided with three files:

- `source.py` : The main python script that encrypts the flag.
- `messages.txt` : A text file that contains some plaintext messages along with the flag.
- `output.txt` : An output file generated by the python script that contains the encrypted messages.

The source code is not that lengthy and it is pretty clear how it works. Let us take a look at the main function first.

```python
def main():
		AE = AdvancedEncryption(128)
    with open('output.txt', 'w') as f:
    		for i in range(len(MSG)):
            ct = AE.encrypt(i, MSG[i])
            f.write(ct.hex()+'\n')

if __name__ == '__main__':
    main()
```

where `MSG` is a list of messages. The flag is one of these messages but it is secret.

```python
with open('messages.txt') as f:
		MSG = eval(f.read())
```

First, the script reads the plaintext messages from  `messages.txt` and stores them in the variable `MSG`. Then, an instance of the `AdvancedEncryption` class is initialized which will be examined at second phase. Finally, there is a loop that iterates through all of the messages and encrypts them one by one saving each of them to the output file `output.txt`. Before moving on, let us write a function that loads the data from the output file and the messages from `messages.txt`.

```python
from Crypto.Util.Padding import pad

def load_data():
		with open('messages.txt') as f:
      	# source script used padding too so we need to align with it.
    		msgs = [pad(m.encode(), 16) for m in eval(f.read())]
    with open('output.txt') as f:
        cts = [bytes.fromhex(line.strip()) for line in f.readlines()]
    
    return msgs, cts
```

The execution flow is standard so let us inspect how the messages are encrypted in the `AdvancedEncryption` class.

```python
class AdvancedEncryption:
		def __init__(self, block_size):
        self.KEYS = self.generate_encryption_keys()
        self.CTRs = [Counter.new(block_size, initial_value=i) for i in range(len(MSG))]

    def generate_encryption_keys(self):
        keys = [[b'\x00']*16] * len(MSG)
        for i in range(len(keys)):
            for j in range(len(keys[i])):
                keys[i][j] = os.urandom(1)
        return keys
    
    def encrypt(self, i, msg):
        key = b''.join(self.KEYS[i])
        ctr = self.CTRs[i]
        cipher = AES.new(key, AES.MODE_CTR, counter=ctr)
        return cipher.encrypt(pad(msg.encode(), 16))
```

The encryption algorithm that is used is AES-128 in CTR mode. The class constructor generates the encryption keys and the counters that will be used per message. What stands out is that each counter is initialized with a different initial value.

```
CTRs[0] ==> initial_value = 0
CTRs[1] ==> initial_value = 1
.
.
.
```

The `encrypt` method looks standard AES-CTR encryption so let us examine the constructor and the key generation algorithm.

# Solution

## Finding the vulnerability

### Key generation

The `generate_encryption_keys` method initializes a $4 \times 16$ array that will be used to store a 128-bit key for each of the 4 messages. Initially, the keys are set to null byte strings. Then, the method iterates through each key byte and assigns it a random byte.  At first glance, this method looks like it generates 4 totally random keys but a common thing to do when given a key generation algorithm is run the algorithm locally and view the results. We replace `len(MSG)` with 4 and run the algorithm locally.

```python
import os

def generate_encryption_keys():
    keys = [[b'\x00']*16] * 4
    for i in range(len(keys)):
        for j in range(len(keys[i])):
            keys[i][j] = os.urandom(1)
    return keys

for key in generate_encryption_keys():
		print(key)
```

```text
[b'\x9f', b'\x91', b'\x8c', b'\x94', b'1', b'\t', b'\xf6', b'\xbd', b'<', b'\xb2', b'\x1b', b'p', b'\x9b', b'\xef', b'\xf4', b'\xe4']
[b'\x9f', b'\x91', b'\x8c', b'\x94', b'1', b'\t', b'\xf6', b'\xbd', b'<', b'\xb2', b'\x1b', b'p', b'\x9b', b'\xef', b'\xf4', b'\xe4']
[b'\x9f', b'\x91', b'\x8c', b'\x94', b'1', b'\t', b'\xf6', b'\xbd', b'<', b'\xb2', b'\x1b', b'p', b'\x9b', b'\xef', b'\xf4', b'\xe4']
[b'\x9f', b'\x91', b'\x8c', b'\x94', b'1', b'\t', b'\xf6', b'\xbd', b'<', b'\xb2', b'\x1b', b'p', b'\x9b', b'\xef', b'\xf4', b'\xe4']
```

To our surprise, the four keys are identical. Let us see why this happened. Recall that the array was initialized as `keys = [[b'\x00']*16] * 4`. Initialising a nested list in this manner leads to each entry in the list having the same ID, pointing to the same list object. This is showcased below.

```py
keys = [[b'\x00']*16] * 4
for k in keys:
  	print(id(k))
```

```
4306957184
4306957184
4306957184
4306957184
```

As a result, modifying the first byte of the first element will also modify the first bytes of the rest three elements.

To avoid this issue, we should modify the initialization of the nested list. The code above should be replaced with the following:

```python
keys = [[b'\x00']*16 for _ in range(4)]
for k in keys:
  	print(id(k))
```

```
4306957760
4306960512
4306958016
4306885248
```

We conclude that each message was encrypted with the same key. Let us examine the Counter generation too. 

### Counter Generation

```python
self.CTRs = [Counter.new(block_size, initial_value=i) for i in range(len(MSG))]
```

We can see that a new Counter is initialized for each message. There are two parameters set:

1. `block_size` : Sets the bit length of the counter.
2. `initial_value` : Self explanatory. According to PyCryptodome documentation [[1]](https://pycryptodome.readthedocs.io/en/latest/src/util/util.html#Crypto.Util.Counter.new), if it is not specified, the default value is $0$.

At first glance, key reuse seems not a problem because different initial values are used for each counter. However, this would be true if the messages were just a single block. Let us recall how AES CTR works.

### AES-CTR mode

Recall how the AES works in CTR mode.

<img style="width:70%; text-align: center;" src="assets/ctr.png"/>

This mode utilizes AES to create a keystream that will eventually be XORed with the plaintext to produce the ciphertext.

Therefore the encryption of the $i$-th plaintext block is obtained as:
$$
C_i = M_i\ \oplus\ AES_K(O_i)
$$
where $O_i$ the value of the counter at the $i$-th block.

<h3>Nonce Reuse vulnerability</h3>

In our challenge, $K$ remains the same for each encryption. Let us now take an example of two messages and see how they are encrypted behind the scenes.

We randomly pick the messages:

```
Hm, I have heard that AES-CTR is a secure encryption mode!

I think it is not possible to break it, right?
```

The encryption of the first message is as follows:
$$
C_0 = M_0 \oplus AES_K(O_0)\\
C_1 = M_1 \oplus AES_K(O_1)\\
C_2 = M_2 \oplus AES_K(O_2)
$$
and so on. Remember that the initial value of the counter for the first message is $0$ while for the second is $1$. Therefore, the second is encrypted as:
$$
C'_0 = M'_0 \oplus AES_K(O_1)\\
C'_1 = M'_1 \oplus AES_K(O_2)
$$
and so on.

As one can see, some plaintext blocks, such as $M_2, M'_1$ are encrypted with the same key-nonce pair. Even though the initial value is different for each message, there is still a nonce reuse vulnerability and as a result this enables us to solve for the unknown flag blocks. The flag is encrypted as:
$$
C''_0 = F_0 \oplus AES_K(O_2)\\
C''_1 = F_1 \oplus AES_K(O_3)\\
C''_2 = F_2 \oplus AES_K(O_4)\\
C''_3 = F_3 \oplus AES_K(O_5)\\
$$

Our goal is to recover $F_0, F_1, F_2$ and $F_3$. Notice that $F_0$ and $F_1$ can be recovered using the encrypted flag and the first or the second known message. The following holds due to the associative XOR property.
$$
F_0 = C''_0 \oplus C'_1 \oplus M'_1\\
F_1 = C''_1 \oplus C'_2 \oplus M'_2\\
$$
For the next blocks, we should use the last message, say $M'''$. The last message is encrypted as:
$$
C'''_0 = M'''_0 \oplus AES_K(O_3)\\
C'''_1 = M'''_1 \oplus AES_K(O_4)\\
C'''_2 = M'''_2 \oplus AES_K(O_5)\\
$$
and so on. Then:
$$
F_2 = C''_2 \oplus C'''_1 \oplus M'''_1\\
F_3 = C''_3 \oplus C'''_2 \oplus M'''_2
$$

# Exploitation

Let us write a function that recovers the flag by computing the values above. We will split the ciphertexts and the messages into blocks to make our code more readable.

```python
from pwn import xor

def blocks(m):
    return [m[i:i+16] for i in range(0, len(m), 16)]

def get_blocks(msgs, cts):
		return blocks(msgs), blocks(cts)

def recover_flag(M, C):
    F0 = xor(C[2][0], C[1][1], M[1][1])
    F1 = xor(C[2][1], C[1][2], M[1][2])
    F2 = xor(C[2][2], C[3][1], M[3][1])
    F3 = xor(C[2][3], C[3][2], M[3][2])
    
    return F0+F1+F2+F3
```

## Getting the flag

So, let us recap our thought process.

1. Notice that the key generation algorithm produces the same keys for each message.
1. Notice that the counters of each message are related.
1. Since both the key and the nonce are reused for some blocks, there is a keystream reused vulnerability.
1. Due to the XOR properties, it is trivial to solve for the flag with only a few XOR operations.

The following python script implements the attack described above and finally outputs the decrypted flag.

```python
def pwn():
    msgs, cts = load_data()
    M, C = get_blocks(msgs, cts)
    f = recover_flag(M, C)
    print(f.decode())
    
pwn()
```
